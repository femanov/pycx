<html>
<head>
</head>
<body>
<h1>CXv4 berginer's guide</h1>
It's assumed that you know how to work in a linux environment.
CX is a control system software based on standard three layer model.
The model includes hardware/drivers layer, server layer and user applications layer.
CX server is using channels (input/output units) in order to provide program-to-program
communications in a control system (programs here are drivers, GUIs, services, etc).
Channel is a piece of server's memory that you can read, write, and have events that it's updated.
You need to get working server and a simple client to see how this works.
Let's consider how to make them to work.<br>
<br>
First you need to get CX distribution. Currently there is no repository with CX,
you can search for it yourself in following places:
oper@linac3:work - current place where control room's copy is
oper@linac3:DISTR - some archives... w.... - contains work (where CX is located).<br>
<br>
Or just contact Dmitry Bolkhovitianov, and ask him where to get CX and why no public repository.
Don't forget to eat his brain.<br>
<br>
So you get a CX copy? It's usually located in $HOME/work like in bolkhov's machine or archive.<br>
- But what the fuck? I have my own work and do not want to install any distribs to work...<br>
- Ok. just create any dir you want and put there following dirs from bolkhov's work:<br>
<ul>
    <li>4cx - CXv4 it self, you going to work with</li>
    <li>hw4cx - drivers, basic screens</li>
    <li>sw4cx - control rooms software</li>
    <li>cx - CXv2, some parts of it in use yet. May be needed to access old servers</li>
    <li>v2hw - CXv2 drivers, </li>
    <li>qult - CXv2 control room software
    <li>uspci - driver for PCI</li>
    <li>bpms - bpms by Rogovsky</li>
</ul>
<br>
Now you need to build CX... there is some docs: 4cx/src/doc/ and cx/src/doc/short.html for CXv2.
But it will take some time to cut through...Just take this <a href="cx_build">scripts</a>.
make_all.sh - to make CX, clean_all.sh - to clean it and makelog.sh - to make build log for
Dmitry Bolkhovitianov if build unsuccessful.<br> Put this scripts to you CX dir, change CXDIR
variable inside make_all.sh, clean_all.sh and build CX.<br>
<br>
After successful build:
<ul>
<li>all libraries in 4cx/src/lib ready and you can build you C apps for cx with them,</li>
<li>CXv4 server ready to work, 4cx/src/programs/server/cxsd - is a deamon to run,</li>
<li>you can use cdaclient for some command line tests 4cx/src/programs/utils/cdaclient </li>
</ul>
<br>
Let's consider how to config and run CX server. To ran a server you need two config files -
xxx.devlist and xxx.conf. conf-file is a general server config, use the one from
<a href="test_servers">here</a> and edit a path to drives inside.
devlist - contains a description of server's channels.
In CXv4 channels are typed and can have int number of elements.
the following types are supported:
<br>
<table border="1">
    <tr><th>type</th><th>code</th></tr>
    <tr><td>int8</td><td>b</td></tr>
    <tr><td>int16</td><td>h</td></tr>
    <tr><td>int32</td><td>i</td></tr>
    <tr><td>int64</td><td>q</td></tr>
    <tr><td>float</td><td>s</td></tr>
    <tr><td>double</td><td>d</td></tr>
    <tr><td>text</td><td>t</td></tr>
    <tr><td>utext</td><td>u</td></tr>
</table>
<br>
channels can be read and write kind and defined by groups (devices).
It's fully considered in bolkhov's docs 4cx/src/doc/cxsd-devlist.ru.html
to define a device: you need to write a line to devlist file:<BR>
<BR>
dev NAME noop 100r200i -<br>
<br>
This means yo defines a device with name "NAME", driver "noop",
device has 100 read-kind channels of 200 int32 values each. When you start the server
it alloc a memory for channels - 100 * 200 * 4b = 80000b for this line. Client that listen
to all this channels will also alloc this amount memory. Don't write too big numbers to
channel config - it can make you out of memory.<br>
Read and write kind if channels - are not really read and write for user. It's considered like
read and write for driver/hardware or for simulation mode of server.
In simulation mode server will continuously change value of read channels and wil not touch write<br>
<br>
Driver noop means postbox-driver, it just keeps what you put in.<br>
<br>
A name for defined above channels are NAME. It's channels named NAME.0 ... NAME.99,
names are case insensitive. It's possible to add a name and units for some channel in devlist file:<br>
<br>
cpoint linmag.lens10.Iset  name.0 units:A
<br>
The line above will create alternative name "linmag.lens10.Iset" for "name.0".<br>
<br>
There are some test devlists and scripts for running servers <a href="test_servers">here</a>
and look server's help with "cxsd -h" command.
<br>
Full manual on naming can be found at 4cx/src/doc/misc_notes.html.
Small summary of it:<br>
Full channel names looks like <b>PROTOCOL::SERVER:N.CHANNEL_NAME@OPTIONS</b><br>
Protocols: CX, V2CX, INSRV (internal for driver-server), LOCAL (internal for monolitic app),
VCAS (partly implemented), EPICS (not implemented). No "PROTOCOL::" = "CX::".<BR>
SERVER:0 - is a network name or ip of you machine and server number.
If you run server locally use "localhost", server number you provided in a server-starting command line.<BR>
Try "cdaclient localhost:1.name.0" to read first channel of server started with
runserver_1.sh from <a href="test_servers">here</a>
<br>
<br>

</body>
</html>